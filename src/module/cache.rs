// Copyright (C) 2003, 2004 Jason Bevins, 2016 Matthew Nicholls
//
// This library is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or (at
// your option) any later version.
//
// This library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
// License (COPYING.txt) for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use module::Module;
use std::cell::Cell;

/// Noise module that caches the last output value generated by a source module.
///
/// If an application passes an input value to the
/// [`get_value()`](struct.Cache.html#method.get_value) method that differs from
/// the previously passed-in input value, this noise module instructs the source
/// module to calculate the output value.  This value, as well as the (`x`, `y`,
/// `z`) coordinates of the input value, are stored (cached) in this noise
/// module.
///
/// If the application passes an input value to the `get_value()` method that is
/// equal to the previously passed-in input value, this noise module returns the
/// cached output value without having the source module recalculate the output
/// value.
///
/// If an application passes a new source module to the
/// [`set_module()`](struct.Cache.html#method.set_module) method, the cache is
/// invalidated.
///
/// Caching a noise module is useful if it is used as a source module for
/// multiple noise modules.  If a source module is not cached, the source module
/// will redundantly calculate the same output value once for each noise module
/// in which it is included.
///
/// This noise module requires one source module.
pub struct Cache<M: Module> {
    module: M,
    cached_value: Cell<f64>,
    is_cached: Cell<bool>,
    x_cache: Cell<f64>,
    y_cache: Cell<f64>,
    z_cache: Cell<f64>,
}

impl<M: Module> Cache<M> {
    /// Create a new `Cache` noise module around the specified module.
    pub fn new(module: M) -> Cache<M> {
        Cache {
            module: module,
            cached_value: Cell::new(0.0),
            is_cached: Cell::new(false),
            x_cache: Cell::new(0.0),
            y_cache: Cell::new(0.0),
            z_cache: Cell::new(0.0),
        }
    }

    /// Returns a reference to the source module used.
    pub fn module(&self) -> &M {
        &self.module
    }

    /// Returns a mutable reference to the source module used.
    ///
    /// This operation invalidates the cache.
    pub fn module_mut(&mut self) -> &mut M {
        self.is_cached.set(false);
        &mut self.module
    }

    /// Set the source module to be used.
    ///
    /// This operation invalidates the cache.
    pub fn set_module(&mut self, module: M) {
        self.module = module;
        self.is_cached.set(false);
    }
}

impl<M: Module> Module for Cache<M> {
    fn get_value(&self, x: f64, y: f64, z: f64) -> f64 {
        if self.is_cached.get()
            && x == self.x_cache.get()
            && y == self.y_cache.get()
            && z == self.z_cache.get() {
            self.cached_value.get()
        } else {
            let ret = self.module.get_value(x, y, z);
            self.cached_value.set(ret);
            self.is_cached.set(true);
            self.x_cache.set(x);
            self.y_cache.set(y);
            self.z_cache.set(z);
            ret
        }
    }
}

impl<M: Module + Clone> Clone for Cache<M> {
    fn clone(&self) -> Cache<M> {
        Cache {
            module: self.module.clone(),
            cached_value: self.cached_value.clone(),
            is_cached: self.is_cached.clone(),
            x_cache: self.x_cache.clone(),
            y_cache: self.y_cache.clone(),
            z_cache: self.z_cache.clone(),
        }
    }
}
